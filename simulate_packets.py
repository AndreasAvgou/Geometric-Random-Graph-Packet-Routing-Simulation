import numpy as np
import networkx as nx

def simulate_packets(G, positions, sink, lambd, steps):
    """
    Statistically calculates the packet load on each node using Shortest Path routing.
    
    NOTE: This uses an analytical approach to avoid the performance penalty of 
    iterating 1,000,000 times in a loop.
    
    Args:
        G (networkx.Graph): The network graph.
        positions (np.array): Node coordinates.
        sink (int): ID of the sink node.
        lambd (float): Probability of packet generation per step.
        steps (int): Total simulation time steps.
        
    Returns:
        tuple: (forwarded_packets array, total_received_at_sink)
    """
    n = G.number_of_nodes()
    forwarded_packets = np.zeros(n)
    
    # Calculate total packets generated by ONE node over the entire simulation
    # Expected value = Time Steps * Probability (lambda)
    packets_per_node = steps * lambd
    
    # Compute shortest paths from ALL nodes to the sink
    # Returns a dictionary: {source_node: [list_of_nodes_in_path]}
    try:
        all_paths = nx.shortest_path(G, target=sink)
    except nx.NetworkXNoPath:
        # Should not happen if graph is connected
        return forwarded_packets, 0

    # Iterate through every node's path to the sink
    for source, path in all_paths.items():
        # 'path' looks like: [Source, Hop1, Hop2, ..., Sink]
        
        for node in path:
            # Every node in the path (including source and sink) "handles" the packet.
            # We add the expected load to that node.
            forwarded_packets[node] += packets_per_node

    # The sink's load represents the total packets successfully received
    total_received = forwarded_packets[sink]
    
    return forwarded_packets, total_received